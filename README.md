# Demo: Rule Engine

## Running the project

1. Install the frontend dependencies.
   ```sh
   (cd frontend && pnpm install)
   ```
2. Run the project using the following commands or the "Fullstack" VSCode debug configuration.
   - Backend
     ```sh
     cd backend && go run .
     ```
   - Frontend
     ```sh
     cd frontend && pnpm run dev
     ```
3. View the running project:

   - [Application](http://localhost:3000/)
   - [API playground](http://localhost:8080/)

## Goals

My goals for this project are to:

- Showcase my strengths:
  - User experience focus
  - Elegant architecture, clean code
  - Forward thinking: maintainability and extensibility
- Challenge myself with a new technology: Go

## Architecture

### Backend

#### API - GraphQL

This application is powered by a GraphQL API.

GraphQL holds up to real production needs by offering the following:

- Amazing developer experience
  - Easy schema iteration
  - Mature tooling that increases engineering velocity by automating busywork
- Strict typing, improving readability and documentation generation
- Performant requests
  - Clients can request only the needed fields
  - Multiple resources can be bundlded in a single request
- Simpler versioning than REST
- Simpler error handling

#### Language - Go

I implemented the GraphQL API using Go and the chi http router. I decided to use a schema-first approach to build the GraphQL API, so much of the code is generated by gqlgen with the exception of:

- main.go
- schema.graphqls
- schema.resolvers.go

[!NOTE]
Schema-first development is a lightweight approach that emphasizes agility by generating boilerplate code and leaving engineers free to focus their time on the schema and business logic. It is recommended as a best practice by notable voices in the GraphQL community, such as [Apollo](https://www.apollographql.com/blog/using-graphql-with-golang#gqlgen-a-schema-first-approach-to-building-graphql-apis) and [Principled GraphQL](https://principledgraphql.com/agility#5-use-an-agile-approach-to-schema-development).

### Frontend

I implemented the frontend in [TypeScript](https://www.typescriptlang.org/). I am a huge fan of static typing and the ways it improves both code readability and quality.

For the frontend framework, I chose to use [Vue.js](https://vuejs.org/). As the fundamental UI components themselves are not part of my focus for this project, I simplified things by utilizing the [Vuetify](https://vuetifyjs.com/) Component framework.

Data is fetched using the [Vue Apollo](https://apollo.vuejs.org/) integration. This drastically simplifies the development process by providing utilities for queries and component state management.

Other notable tooling:

- [Vite](https://vite.dev/): Frontend build tool and development server
- [unplugin-vue-router](https://github.com/posva/unplugin-vue-router): Easy routing based on folder structure
- [VueDraggablePlus](https://vue-draggable-plus.pages.dev/): Drag and drop functionality (based on Sortable.js)
- [Lodash](https://lodash.com/): Library of useful utility functions
- [GraphQL Codegen](https://the-guild.dev/graphql/codegen): Autogenerates types from the GraphQL API
- [Eslint](https://eslint.org/): Linting and autoformatting

## Potential improvements

1. Implement backend logic to actually run steps
2. Connect backend to a relational database
3. Support multiple content types for API request steps
4. Implement a better editing component for JSON API requests
5. Add mobile support to the flow editor
6. Add a confirmation dialog for the step deletion button
7. Implement flow deletion
8. Bug: Save button is enabled before a valid step is added
