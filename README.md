# Demo: Automation Builder

Live demo: [App](https://automationbuilder.ferns.land/) | [API](https://api.automationbuilder.ferns.land/)

This application is a demonstration of an automation builder interface. Users are able to create and manage "flows": sequences of configurable steps, such as making an API request or sending an email. This enables users to simplify common business tasks and processes.

Example automation:

![Automation Builder Diagram](https://github.com/user-attachments/assets/4d38f21c-d19f-413a-aa4c-095d61b9a7f2)


## Goals

My goals for this project are to:

- Showcase my strengths:
  - User experience focus
  - Elegant architecture, clean code
  - Forward thinking: maintainability and extensibility
- Challenge myself with a new technology: Go

## Running the project

1. Install the frontend dependencies.
   ```sh
   (cd frontend && pnpm install)
   ```
2. Run the project using the following commands or the "Fullstack" VSCode debug configuration.
   - Backend
     ```sh
     cd backend && go run .
     ```
   - Frontend
     ```sh
     cd frontend && pnpm run dev
     ```
3. View the running project:

   - [Application](http://localhost:3000/)
   - [API playground](http://localhost:8080/)

## Architecture

### Backend

#### API - GraphQL

This application is powered by a GraphQL API.

GraphQL holds up to real production needs by offering the following:

- Amazing developer experience
  - Easy schema iteration
  - Mature tooling that increases engineering velocity by automating busywork
- Strict typing, improving readability and documentation generation
- Performant requests
  - Clients can request only the needed fields
  - Multiple resources can be bundlded in a single request
- Simpler versioning than REST
- Simpler error handling

#### Language - Go

I implemented the GraphQL API using Go and the chi http router. I decided to use a schema-first approach to build the GraphQL API, so much of the code is generated by gqlgen with the exception of:

- main.go
- schema.graphqls
- schema.resolvers.go

[!NOTE]
Schema-first development is a lightweight approach that emphasizes agility by generating boilerplate code and leaving engineers free to focus their time on the schema and business logic. It is recommended as a best practice by notable voices in the GraphQL community, such as [Apollo](https://www.apollographql.com/blog/using-graphql-with-golang#gqlgen-a-schema-first-approach-to-building-graphql-apis) and [Principled GraphQL](https://principledgraphql.com/agility#5-use-an-agile-approach-to-schema-development).

### Frontend

I implemented the frontend in [TypeScript](https://www.typescriptlang.org/). I am a huge fan of static typing and the ways it improves both code readability and quality.

For the frontend framework, I chose to use [Vue.js](https://vuejs.org/). As the fundamental UI components themselves are not part of my focus for this project, I simplified things by utilizing the [Vuetify](https://vuetifyjs.com/) Component framework.

Data is fetched using the [Vue Apollo](https://apollo.vuejs.org/) integration. This drastically simplifies the development process by providing utilities for queries and component state management.

Other notable tooling:

- [Vite](https://vite.dev/): Frontend build tool and development server
- [unplugin-vue-router](https://github.com/posva/unplugin-vue-router): Easy routing based on folder structure
- [VueDraggablePlus](https://vue-draggable-plus.pages.dev/): Drag and drop functionality (based on Sortable.js)
- [Lodash](https://lodash.com/): Library of useful utility functions
- [GraphQL Codegen](https://the-guild.dev/graphql/codegen): Autogenerates types from the GraphQL API
- [Eslint](https://eslint.org/): Linting and autoformatting

## Potential improvements

1. Implement UI for conditional steps
2. Implement backend logic to actually run steps
3. Connect backend to a relational database
4. Support multiple content types for API request steps
5. Implement a better editing component for JSON API requests
6. Add mobile support to the flow editor
7. Add a confirmation dialog for the step deletion button
8. Implement flow deletion
9. Bug: Save button is enabled before a valid step is added
10. Add user authenticationn
